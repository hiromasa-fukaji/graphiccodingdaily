<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle 'A'</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
  </style>
</head>
<body>
  <script>
    let particles = [];
    let points = []; // SVGの元の座標を保持
    let pathElement, bounds;

    let svgPath;
    const density = 0.5; // 点の密度
    const scaleFactor = 1.2; // 表示倍率

    function preload() {
      // SVGのパスデータを直接変数に格納
      svgPath = "M90.87081,468.82712v-19.65869h39.31738v-59.33789h19.7793v59.33789h39.55859v19.65869h-98.65527ZM248.74337,468.82712v-19.65869h39.55859v-59.33789h-19.7793v-19.7793h-98.77588v19.7793h-19.7793v-59.21729h19.7793v19.65869h98.77588v-19.65869h-19.7793v-59.33789h-19.65869v-59.21729h-19.7793v-59.33789h19.7793v-19.7793h19.65869v79.11719h19.7793v59.21729h19.7793v59.33789h19.7793v59.21729h19.7793v59.33789h39.43799v19.65869h-118.55518ZM169.74679,330.61325v-59.33789h19.7793v59.33789h-19.7793ZM189.52609,271.27536v-59.21729h19.7793v59.21729h-19.7793Z";
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);

      // SVGエレメントを作成してDOMに追加（getBBox()が正しく動作するため）
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.visibility = 'hidden';
      document.body.appendChild(svg);
      
      pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      pathElement.setAttribute('d', svgPath);
      svg.appendChild(pathElement);
      
      bounds = pathElement.getBBox();
      console.log('Bounds:', bounds); // デバッグ情報
      
      const pathLength = pathElement.getTotalLength();
      console.log('Path length:', pathLength); // デバッグ情報
      
      for (let i = 0; i < pathLength; i += density) {
        const pt = pathElement.getPointAtLength(i);
        points.push(createVector(pt.x, pt.y));
      }

      points.forEach(() => {
        particles.push(new Particle());
      });
      
      updateTargets();
      
      console.log('Canvas size:', width, 'x', height); // デバッグ情報
      console.log('Sample target positions:', particles[0].target, particles[Math.floor(particles.length/2)].target); // デバッグ情報
    }
    
    function updateTargets() {
      const scaledWidth = bounds.width * scaleFactor;
      const scaledHeight = bounds.height * scaleFactor;
      
      // ウィンドウの中心座標
      const centerX = width / 2;
      const centerY = height / 2;
      
      // SVGパスの中心座標(スケール前のSVG座標系)
      const pathCenterX = bounds.x + bounds.width / 2;
      const pathCenterY = bounds.y + bounds.height / 2;

      for(let i = 0; i < particles.length; i++) {
        const p = points[i];
        // 1. パスの中心からの相対座標に変換
        // 2. スケールを適用
        // 3. ウィンドウの中心に配置
        const x = (p.x - pathCenterX) * scaleFactor + centerX;
        const y = (p.y - pathCenterY) * scaleFactor + centerY;
        particles[i].target.set(x, y);
      }
    }

    function draw() {
      background(0, 50);
      
      for (let particle of particles) {
        particle.behaviors();
        particle.update();
        particle.show();
      }

      // --- デバッグ用の描画 ---
      // 中央配置の計算が正しいかを確認するため、計算された領域を赤い四角で描画します
      const scaledWidth = bounds.width * scaleFactor;
      const scaledHeight = bounds.height * scaleFactor;
      const centerX = width / 2;
      const centerY = height / 2;
      noFill();
      stroke(255, 0, 0); // 赤色
      strokeWeight(2);
      rect(centerX - scaledWidth / 2, centerY - scaledHeight / 2, scaledWidth, scaledHeight);
      
      // 中心点を表示
      stroke(0, 255, 0); // 緑色
      strokeWeight(10);
      point(centerX, centerY);
      
      // 情報をテキストで表示
      fill(255);
      noStroke();
      textSize(12);
      text(`Bounds: x=${bounds.x.toFixed(1)}, y=${bounds.y.toFixed(1)}, w=${bounds.width.toFixed(1)}, h=${bounds.height.toFixed(1)}`, 10, 20);
      text(`Center: ${centerX.toFixed(1)}, ${centerY.toFixed(1)}`, 10, 40);
      text(`Particles: ${particles.length}`, 10, 60);
      // --- デバッグここまで ---
    }

    class Particle {
      constructor() {
        this.pos = createVector(random(width), random(height));
        this.target = createVector(); // updateTargetsで設定
        this.vel = p5.Vector.random2D();
        this.acc = createVector();
        this.r = 2;
        this.maxspeed = 10;
        this.maxforce = 1;
      }

      behaviors() {
        let arrive = this.arrive(this.target);
        this.applyForce(arrive);

        let mouse = createVector(mouseX, mouseY);
        let flee = this.flee(mouse);
        flee.mult(5);
        this.applyForce(flee);
      }

      applyForce(f) {
        this.acc.add(f);
      }

      update() {
        this.pos.add(this.vel);
        this.vel.add(this.acc);
        this.acc.mult(0);
        this.vel.limit(this.maxspeed);
      }

      show() {
        stroke(255, 200, 0);
        strokeWeight(this.r);
        point(this.pos.x, this.pos.y);
      }
      
      arrive(target) {
        let desired = p5.Vector.sub(target, this.pos);
        let d = desired.mag();
        let speed = this.maxspeed;
        if (d < 100) {
          speed = map(d, 0, 100, 0, this.maxspeed);
        }
        desired.setMag(speed);
        let steer = p5.Vector.sub(desired, this.vel);
        steer.limit(this.maxforce);
        return steer;
      }
      
      flee(target) {
        let desired = p5.Vector.sub(target, this.pos);
        let d = desired.mag();
        if (d < 50) {
          desired.setMag(this.maxspeed);
          desired.mult(-1);
          let steer = p5.Vector.sub(desired, this.vel);
          steer.limit(this.maxforce);
          return steer;
        } else {
          return createVector(0, 0);
        }
      }
    }
    
    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        updateTargets();
    }
  </script>
</body>
</html>