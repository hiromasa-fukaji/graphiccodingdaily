<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>EVOLVE - Game of Life Typography</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
    }
  </style>
</head>
<body>
<script>
let canvas;
let grid;
let cols, rows;
let resolution = 6;
let font;
let textPoints = [];
let generation = 0;

// UIスライダー
let resolutionSlider, textSizeSlider, frameRateSlider, fadeSpeedSlider, hueMaxSlider;
let textSize = 600;
let fadeSpeed = 1;
let hueMax = 360;

function preload() {
  font = loadFont('IBMPlexMono-Regular.ttf');
}

function setup() {
  canvas = createCanvas(210*2.5, 297*2.5);
  centerCanvas();
  canvas.style('display', 'block');

  // スライダーUI
  resolutionSlider = createSlider(3, 30, resolution, 1);
  resolutionSlider.position(20, 20);
  resolutionSlider.style('width', '180px');
  resolutionSlider.input(() => {
    resolution = resolutionSlider.value();
    resetGrid();
  });

  textSizeSlider = createSlider(60, 1000, textSize, 1);
  textSizeSlider.position(20, 50);
  textSizeSlider.style('width', '180px');
  textSizeSlider.input(() => {
    textSize = textSizeSlider.value();
    resetGrid();
  });

  frameRateSlider = createSlider(2, 60, 10, 1);
  frameRateSlider.position(20, 80);
  frameRateSlider.style('width', '180px');
  frameRateSlider.input(() => {
    frameRate(frameRateSlider.value());
  });

  fadeSpeedSlider = createSlider(1, 10, fadeSpeed, 1);
  fadeSpeedSlider.position(20, 110);
  fadeSpeedSlider.style('width', '180px');
  fadeSpeedSlider.input(() => {
    fadeSpeed = fadeSpeedSlider.value();
  });

  hueMaxSlider = createSlider(180, 360, hueMax, 1);
  hueMaxSlider.position(20, 140);
  hueMaxSlider.style('width', '180px');
  hueMaxSlider.input(() => {
    hueMax = hueMaxSlider.value();
  });

  cols = floor(width / resolution);
  rows = floor(height / resolution);
  grid = make2DArray(cols, rows);
  initializeWithText();
  frameRate(frameRateSlider.value());
}

function initializeWithText() {
  // オフスクリーングラフィックスでテキストを描画
  let pg = createGraphics(width, height);
  pg.textSize(textSize);
  pg.textAlign(CENTER, CENTER);
  pg.textFont(font);
  pg.background(0);
  pg.fill(255);
  pg.text('A', width/2, height/2);
  pg.loadPixels();
  pg.updatePixels();

  // ピクセルデータからグリッドを初期化
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * resolution + resolution/2;
      let y = j * resolution + resolution/2;
      let c = pg.get(x, y); // [r,g,b,a]
      let brightness = (c[0] + c[1] + c[2]) / 3;
      if (c[3] > 128 && brightness > 50) {
        grid[i][j].alive = true;
        grid[i][j].age = 1;
      }
    }
  }

  // 初期化されたセルの数を確認
  let aliveCount = 0;
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      if (grid[i][j].alive) aliveCount++;
    }
  }
  console.log('Alive cells after initialization:', aliveCount);
}

function draw() {
  // CRTスタイルの背景
  background(5, 5, 15);
  
  
  // グリッドを描画
  let visibleCells = 0;
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * resolution;
      let y = j * resolution;
      let cell = grid[i][j];
      if (cell.alive) {
        visibleCells++;
        // 生存期間に基づいて色を変化させる
        let hue = map(cell.age, 0, 50, 180, hueMax) % 360;
        let brightness = map(cell.age, 0, 30, 60, 100);
        colorMode(HSB, 360, 100, 100);
        noStroke();
        fill(hue, 80, brightness);
        rect(x, y, resolution, resolution);
        colorMode(RGB);
      } else if (cell.fade > 0) {
        // フェードアウト効果
        let fadeHue = 200;
        colorMode(HSB, 360, 100, 100);
        noStroke();
        let alpha = map(cell.fade, 0, 20, 0, 80);
        fill(fadeHue, 70, 60, alpha);
        rect(x, y, resolution, resolution);
        colorMode(RGB);
      }
    }
  }
  
  if (frameCount % 30 === 0) {
    console.log('Frame:', frameCount, 'Visible cells:', visibleCells);
  }
  
  // CRTスキャンライン効果
  drawScanlines();
  
  // Game of Lifeのルールを適用
  let next = make2DArray(cols, rows);
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let state = grid[i][j].alive;
      let neighbors = countNeighbors(grid, i, j);
      
      if (state && (neighbors < 2 || neighbors > 3)) {
        // 死ぬ
        next[i][j] = {alive: false, age: 0, fade: 20};
      } else if (!state && neighbors === 3) {
        // 誕生
        next[i][j] = {alive: true, age: 1, fade: 0};
      } else if (state) {
        // 生き続ける - 年齢を増やす
        next[i][j] = {alive: true, age: grid[i][j].age + 1, fade: 0};
      } else {
        // 死んだまま - フェードを減らす
        next[i][j] = {alive: false, age: 0, fade: max(0, grid[i][j].fade - 1)};
      }
    }
  }
  
  grid = next;
  generation++;
  
  // 全てのセルが死んだら再初期化
  if (generation % 200 === 199) {
    initializeWithText();
  }
}

function countNeighbors(grid, x, y) {
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      let col = (x + i + cols) % cols;
      let row = (y + j + rows) % rows;
      sum += grid[col][row].alive ? 1 : 0;
    }
  }
  sum -= grid[x][y].alive ? 1 : 0;
  return sum;
}

function make2DArray(cols, rows) {
  let arr = new Array(cols);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = new Array(rows);
    for (let j = 0; j < rows; j++) {
      arr[i][j] = {alive: false, age: 0, fade: 0};
    }
  }
  return arr;
}

function resetGrid() {
  cols = floor(width / resolution);
  rows = floor(height / resolution);
  grid = make2DArray(cols, rows);
  initializeWithText();
  generation = 0;
}

function drawScanlines() {
  stroke(0, 255, 150, 10);
  for (let i = 0; i < height; i += 4) {
    line(0, i, width, i);
  }
  
  // CRTビネット効果
  noStroke();
  for (let i = 0; i < 40; i++) {
    let alpha = map(i, 0, 40, 0, 100);
    fill(0, alpha);
    rect(0, 0, width, i);
    rect(0, height - i, width, i);
    rect(0, 0, i, height);
    rect(width - i, 0, i, height);
  }
}

function windowResized() {
  centerCanvas();
}

function centerCanvas() {
  let x = (windowWidth - width) / 2;
  let y = (windowHeight - height) / 2;
  canvas.position(x, y);
}

// クリックで再初期化
function mousePressed() {
  initializeWithText();
  generation = 0;
}
</script>
</body>
</html>
