<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Particle A - Creative Coding</title>
	<style>
		body {
			margin: 0;
			background: #111;
			color: #fff;
			font-family: 'IBM Plex Mono', monospace;
			overflow: hidden;
		}
		#defaultCanvas0 {
			display: block;
			margin: 0 auto;
		}
		.control-panel {
			position: fixed;
			top: 10px;
			left: 10px;
			z-index: 10;
			background: #222;
			padding: 12px;
			border-radius: 8px;
		}
		.control-panel label {
			display: block;
			margin: 8px 0;
		}
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<div class="control-panel">
  <label>SVGサイズ: <input type="range" id="svgSize" min="1" max="10" step="0.1" value="5"></label>
  <label>磁力: <input type="range" id="magnet" min="0.01" max="0.2" step="0.01" value="0.05"></label>
  <label>パーティクル密度: <input type="range" id="density" min="2" max="20" step="1" value="5"></label>
</div>
<script>

let particles = [];
let baseImg;
let svgSize = 0.2;
let magnet = 0.05;
let particleStep = 5;
let invisiblePoints = [];
let invisibleNum = 25;

function setup() {
    createCanvas(windowWidth, windowHeight);
    background(17);
    noStroke();
    loadImage('b.jpg', img => {
        baseImg = img;
        drawBaseAndParticles();
    });
    document.getElementById('svgSize').addEventListener('input', e => {
        svgSize = parseFloat(e.target.value);
        drawBaseAndParticles();
    });
    document.getElementById('magnet').addEventListener('input', e => {
        magnet = parseFloat(e.target.value);
        drawBaseAndParticles();
    });
    document.getElementById('density').addEventListener('input', e => {
        particleStep = parseInt(e.target.value);
        drawBaseAndParticles();
    });
    invisiblePoints = [];
    for (let i = 0; i < invisibleNum; i++) {
        invisiblePoints.push({
            pos: createVector(random(width), random(height)),
            vel: p5.Vector.random2D().mult(random(1,3))
        });
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    drawBaseAndParticles();
}

function drawBaseAndParticles() {
    background(17);
    particles = [];
    let imgW = baseImg.width * svgSize;
    let imgH = baseImg.height * svgSize;
    let rows = 2, cols = 2;
    let totalW = imgW * cols;
    let totalH = imgH * rows;
    let startX = (width - totalW) / 2;
    let startY = (height - totalH) / 2;
    // 一時キャンバスでb画像部分のみ判定
    let pg = createGraphics(width, height);
    pg.background(255); // 白で初期化
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            let x = startX + col * imgW;
            let y = startY + row * imgH;
            pg.image(baseImg, x, y, imgW, imgH);
        }
    }
    pg.loadPixels();
    let density = pixelDensity();
    for (let i = 0; i < width; i += particleStep) {
        for (let j = 0; j < height; j += particleStep) {
            let idx = 4 * ((j * density) * width * density + (i * density));
            let r = pg.pixels[idx];
            let g = pg.pixels[idx+1];
            let b = pg.pixels[idx+2];
            // b画像の黒部分のみパーティクル生成
            if (r < 50 && g < 50 && b < 50) {
                particles.push(new Particle(i, j));
            }
        }
    }
    // メインキャンバスにb画像を描画
    background(17);
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            let x = startX + col * imgW;
            let y = startY + row * imgH;
            image(baseImg, x, y, imgW, imgH);
        }
    }
}

function draw() {
    background(17);
    // 赤い円の衝突判定と反射
    for (let i = 0; i < invisiblePoints.length; i++) {
        let ptA = invisiblePoints[i];
        ptA.pos.add(ptA.vel);
        if (ptA.pos.x < 0 || ptA.pos.x > width) ptA.vel.x *= -1;
        if (ptA.pos.y < 0 || ptA.pos.y > height) ptA.vel.y *= -1;
        for (let j = i + 1; j < invisiblePoints.length; j++) {
            let ptB = invisiblePoints[j];
            let distAB = p5.Vector.dist(ptA.pos, ptB.pos);
            let r = 9; // 半径
            if (distAB < r * 2) {
                // 速度ベクトルを入れ替えて反射
                let temp = ptA.vel.copy();
                ptA.vel = ptB.vel.copy();
                ptB.vel = temp;
                // 衝突後、重なりを解消
                let overlap = r * 2 - distAB;
                let dir = p5.Vector.sub(ptA.pos, ptB.pos).normalize();
                ptA.pos.add(dir.mult(overlap / 2));
                ptB.pos.sub(dir.mult(overlap / 2));
            }
        }
    }
    fill(255, 80, 80, 180);
    noStroke();
    for (let pt of invisiblePoints) {
        ellipse(pt.pos.x, pt.pos.y, 18, 18);
    }
    for (let p of particles) {
        p.update();
        p.show();
    }
}

class Particle {
    constructor(x, y) {
        this.base = createVector(x, y);
        this.pos = createVector(x + random(-10,10), y + random(-10,10));
        this.vel = p5.Vector.random2D().mult(random(0.5,2));
        this.acc = createVector(0,0);
        this.r = random(2,5);
        this.t = random(TWO_PI);
    }
    update() {
        // 元の位置に戻る力（磁力パラメータ化）
        let force = p5.Vector.sub(this.base, this.pos).mult(magnet);
        this.acc.add(force);

        // マウスから逃げる力
        let mouse = createVector(mouseX, mouseY);
        let d = p5.Vector.dist(this.pos, mouse);
        let repelRadius = 20; // 100の5分の1
        if (d < repelRadius) {
            let repel = p5.Vector.sub(this.pos, mouse);
            repel.setMag((repelRadius - d) * 0.3); // 距離が近いほど強く反発
            this.acc.add(repel);
        }

        // 目に見えない点からも磁力
        for (let pt of invisiblePoints) {
            let d2 = p5.Vector.dist(this.pos, pt.pos);
            if (d2 < repelRadius) {
                let repel2 = p5.Vector.sub(this.pos, pt.pos);
                repel2.setMag((repelRadius - d2) * 0.3);
                this.acc.add(repel2);
            }
        }
        this.vel.add(this.acc);
        this.vel.mult(0.92);
        this.pos.add(this.vel);
        this.acc.mult(0);
        this.t += 0.05;
        this.pos.x += sin(this.t) * 0.5;
        this.pos.y += cos(this.t) * 0.5;
    }
    show() {
        noStroke();
        fill(0, 200, 255); // 不透明な青
        ellipse(this.pos.x, this.pos.y, this.r, this.r);
    }
}
</script>
</body>
</html>

